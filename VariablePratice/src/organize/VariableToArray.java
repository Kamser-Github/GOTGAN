package organize;

public class VariableToArray {
	
	/*
	1.변수(Variable)
		변수는 변하는 수가 아니라
		"단 하나의 값을 저장할 수 있는 메모리 공간"
		
		기본형일경우 기본형 byte의 크기를 따라가고
				  실제의 값이 저장됨.
		
		참조형일경우 64bit일때 8byte의 크기를 가져간다.
				 객체의 주소값이 저장됨(Ox000000ffff)
				 
		
		*type
		 boolean 조건식과 논리적 계산에 사용
		 
		*정수형 Overflow
		 byte,short,int,long
		  모두 한계치를 넘어가면 Mix값과 Min값이 붙어있어서 넘어가진다.
		
		*형변환
		 int보다 작은수끼리 계산하면 자동으로 int로 형변환되고
	   	  계산이 되어지는데 이때 문제가 발생한다.
		 byte a = 10;
		 byte b = 20;
		 byte c = a + b ;//오류발생
		 byte c = (int)a+(int)b; 가 되면서
		 byte의 타입으로 받지를 못한다.
		 int c로 받거나 (byte)(a+b)로 바꿔야한다.
		
	2.연산자 (Operator)
		
		*진행순서
		 대부분 -> 으로 연산
		 대입,단항만 <-으로 연산
		 
		*우선순위
		 논리연산자끼리 우선순위가 다르다
		 &&,&가 ||,|보다 우선 순위가 높다.
		 a | b && c 이면
		 b&&c -> a | d 를 계산한다.
		
		 부호 연산자(-)
		  값에 -1을 곱한다.
		 
		 논리부정연산자 (!)
		  boolean일경우 반대값으로 바꾼다
		 
		 *이항 연산자 특징( * > / && etc)
		  범위가 큰 기본형타입으로 변환하고 계산한다.
		  이때 char,byte등은 이항연산자를 계산후에는
		  형변환을 해주거나 넓은 타입으로 받아야한다
		 char a = 'a';
		 char c = a+1;//에러 int형으로 바뀐다.
		 char c = (char)('a'+1);
		 char c = a++,++a; //가능 단항연산자이기 때문.
		 
		*비교연산자
		 > < = 도 마찬가지로 피연산자 타입 통일 된다.
		 참조형은 == !=만 쓸수있다.
		 
		*논리연산자
		 ★피연산자의 값이 무조건 boolean형이여야한다.
		
		*삼항연산자
		 ( 식  ) ? A : B ;
		   식이 true 면 A;
		   식이 false 면 B;
		  이때 값을 받아주는 변수가 필요하다.
		
	 3.조건문 반복문
	 	
	 	조건문 - if , switch
	 	
	 	*if , if -else, if -else if -else
	 	조건식은 반드시 ture , false값이 나와야한다.
	 	
	 	[조건을 만족하면 해당 블럭을 뛰어 넘어간다]
	 
	 	*switch(조건식)
	 	조건식의 결과가 무조건
	 	"문자열",int형이여야한다.
	 	"문자열",정수,char까지
	 	
	 	[조건을 만족하고 break로 안잡아주면 밑에있는 애들꺼도 같이 쓴다]
	 	
	 	*반복문 ( for , while , do-while)
	 	 (조건식),{반복할 문장} 으로 구성
	 	 
	 	 ★for문의 구조
	 	 for(초기화 ; 조건식 ; 증감식 )
	 	 
	 	 [ 반복횟수를 알고있을때,
	 	      반복횟수로 반복시키고 싶을때,]
	 	  
	 	   조건식이 true일때만 반복문장이 돌아간다 !!!!
	 	  
	 	 여기서 초기화구문은 한번만 실행
	 	 조건식->반복문장->증감식 을 계속 반복
	 	 따라서 조건식이 매서드를 호출할경우 계속 돌아가기때문에
	 	 상수로 지정해주는것이 좋다.
	 	 
	 	 [continue는 증감식으로 이동]
	 	 
	 	 final int NUM_LENGTH = nums.length();
	 	 for(int i=0; i<NUM_LENGTH ; i++)
	 	 
	 	 ★while문의 구조
	 	 while(조건식){반복문}
	 	 
	 	[ 몇번 돌려질지 모를때 사용]
	 	 
	 	  조건식이 true면 반복문이 계속 돌아간다.
	 	  따라서 멈추게할 break나 매서드에 속해있으면 return을쓴다.
	 	  하나하나 카운트를 하는 경우라면 for문을 쓰는게 낫다.
	 	 
	 	 [continue는 조건식으로 넘어가진다]
	 	 
	 	
	 4.배열
	 	
	 	같은 타입의 변수를 순차적으로 묶어 놓은것.
	 	
	 	int[] a = new int[length];
	 	int[] a = { } ;
	 	int[] a ;
	 	a = new int[]{};
	 	[선언과 초기화를 동시에 안할거면 생략이 불가능하다.]
	 	
	 	기본 8개 타입이 아니면 다 참조형이기 때문에
	 	a에는 참조값이 저장된다.
	 	
	 	배열 복사방법
	 	
	 	1.for
	 	2.System.array.copy(arr1,startIndex,arr2,arr1[startIndex].길이);
	 	
	 	arr1을 arr2로 복사할건데
	 	startIndex에서 입력한 길이까지 복사된다.
	 	
	 	이때 기본형일경우 값이 저장되어있어서 상관없지만
	 	
	 	[참조형 배열일경우엔 참조값만 복사 저장되는거기 때문에
	 	  참조변수로 값을 변경하면 다같이 값이 변경된다]
	 	
	 	
	 	
		
		
		
		
		
		
	
	
	
	
	
	
	
	
	
	*/
}
